{
  "methods": {
    "addGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "addGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "addNmeaListener(android.location.OnNmeaMessageListener,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 24,
      "name": "addNmeaListener(android.location.OnNmeaMessageListener,android.os.Handler)"
    },
    "addNmeaListener(java.util.concurrent.Executor,android.location.OnNmeaMessageListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "addNmeaListener(java.util.concurrent.Executor,android.location.OnNmeaMessageListener)"
    },
    "createRealProperties(boolean,boolean,boolean,boolean,boolean,boolean,boolean,int,int)": {
      "isImplementation": false,
      "modifiers": [
        "protected"
      ],
      "params": [
        "requiresNetwork",
        "requiresSatellite",
        "requiresCell",
        "hasMonetaryCost",
        "supportsAltitude",
        "supportsSpeed",
        "supportsBearing",
        "powerRequirement",
        "accuracy"
      ],
      "returnType": "java.lang.Object",
      "exceptions": [],
      "name": "createRealProperties(boolean,boolean,boolean,boolean,boolean,boolean,boolean,int,int)"
    },
    "distanceBetween(android.location.Location,android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "location1",
        "location2"
      ],
      "returnType": "float",
      "exceptions": [],
      "name": "distanceBetween(android.location.Location,android.location.Location)",
      "documentation": "Returns the distance between the two locations in meters. Adapted from:\nhttp://stackoverflow.com/questions/837872/calculate-distance-in-meters-when-you-know-longitude-and-latitude-in-java\n"
    },
    "getAllProviders()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getAllProviders()"
    },
    "getBestProvider(android.location.Criteria,boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "enabled"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getBestProvider(android.location.Criteria,boolean)"
    },
    "getContext()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "android.content.Context",
      "exceptions": [],
      "name": "getContext()"
    },
    "getCurrentLocation(java.lang.String,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "cancellationSignal",
        "executor",
        "consumer"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "getCurrentLocation(java.lang.String,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)"
    },
    "getCurrentLocationInternal(java.lang.String,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "cancellationSignal",
        "executor",
        "consumer"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "getCurrentLocationInternal(java.lang.String,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)"
    },
    "getGpsStatusListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.GpsStatus.Listener\u003e",
      "exceptions": [],
      "name": "getGpsStatusListeners()"
    },
    "getLastKnownLocation(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider"
      ],
      "returnType": "android.location.Location",
      "exceptions": [],
      "name": "getLastKnownLocation(java.lang.String)"
    },
    "getLocationMode()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getLocationMode()"
    },
    "getLocationUpdateListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getLocationUpdateListeners()",
      "documentation": "Retrieves a list of all currently registered listeners.\n\n@deprecated Do not test listeners, instead use {@link #simulateLocation(Location)} and test the\n    results of those listeners being invoked.\n"
    },
    "getLocationUpdateListeners(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getLocationUpdateListeners(java.lang.String)",
      "documentation": "Retrieves a list of all currently registered listeners for the given provider.\n\n@deprecated Do not test listeners, instead use {@link #simulateLocation(Location)} and test the\n    results of those listeners being invoked.\n"
    },
    "getLocationUpdatePendingIntents()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.app.PendingIntent\u003e",
      "exceptions": [],
      "name": "getLocationUpdatePendingIntents()",
      "documentation": "Retrieves a list of all currently registered pending intents.\n\n@deprecated Do not test pending intents, instead use {@link #simulateLocation(Location)} and\n    test the results of those pending intent being invoked.\n"
    },
    "getLocationUpdatePendingIntents(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "java.util.List\u003candroid.app.PendingIntent\u003e",
      "exceptions": [],
      "name": "getLocationUpdatePendingIntents(java.lang.String)",
      "documentation": "Retrieves a list of all currently registered pending intents for the given provider.\n\n@deprecated Do not test pending intents, instead use {@link #simulateLocation(Location)} and\n    test the results of those pending intent being invoked.\n"
    },
    "getOrCreateProviderEntry(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name"
      ],
      "returnType": "org.robolectric.shadows.ShadowLocationManager.ProviderEntry",
      "exceptions": [],
      "name": "getOrCreateProviderEntry(java.lang.String)"
    },
    "getProvider(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "name"
      ],
      "returnType": "android.location.LocationProvider",
      "exceptions": [],
      "name": "getProvider(java.lang.String)"
    },
    "getProviderEntry(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name"
      ],
      "returnType": "org.robolectric.shadows.ShadowLocationManager.ProviderEntry",
      "exceptions": [],
      "name": "getProviderEntry(java.lang.String)"
    },
    "getProviders(android.location.Criteria,boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "enabled"
      ],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getProviders(android.location.Criteria,boolean)"
    },
    "getProviders(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "enabledOnly"
      ],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getProviders(boolean)"
    },
    "getRequestLocationUpdateListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getRequestLocationUpdateListeners()",
      "documentation": "@deprecated Use {@link #getLocationUpdateListeners()} instead. "
    },
    "injectLocation(android.location.Location)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "location"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 28,
      "name": "injectLocation(android.location.Location)"
    },
    "isLocationEnabled()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isLocationEnabled()"
    },
    "isLocationEnabledForUser(android.os.UserHandle)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "userHandle"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 28,
      "name": "isLocationEnabledForUser(android.os.UserHandle)"
    },
    "isProviderEnabled(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isProviderEnabled(java.lang.String)"
    },
    "loadLocationProviderConstructor()": {
      "isImplementation": false,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.reflect.Constructor\u003candroid.location.LocationProvider\u003e",
      "exceptions": [
        "java.lang.ReflectiveOperationException"
      ],
      "name": "loadLocationProviderConstructor()"
    },
    "registerAntennaInfoListener(java.util.concurrent.Executor,android.location.GnssAntennaInfo.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerAntennaInfoListener(java.util.concurrent.Executor,android.location.GnssAntennaInfo.Listener)"
    },
    "registerGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 24,
      "name": "registerGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback,android.os.Handler)"
    },
    "registerGnssMeasurementsCallback(java.util.concurrent.Executor,android.location.GnssMeasurementsEvent.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "callback"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerGnssMeasurementsCallback(java.util.concurrent.Executor,android.location.GnssMeasurementsEvent.Callback)"
    },
    "registerGnssStatusCallback(android.location.GnssStatus.Callback,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 24,
      "name": "registerGnssStatusCallback(android.location.GnssStatus.Callback,android.os.Handler)"
    },
    "registerGnssStatusCallback(java.util.concurrent.Executor,android.location.GnssStatus.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "callback"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerGnssStatusCallback(java.util.concurrent.Executor,android.location.GnssStatus.Callback)"
    },
    "removeGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "removeListenerInternal(java.lang.Object)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "key"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeListenerInternal(java.lang.Object)"
    },
    "removeNmeaListener(android.location.OnNmeaMessageListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "removeNmeaListener(android.location.OnNmeaMessageListener)"
    },
    "removeProvider(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeProvider(java.lang.String)",
      "documentation": "Completely removes a provider. "
    },
    "removeProviderEntry(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeProviderEntry(java.lang.String)"
    },
    "removeUpdates(android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdates(android.app.PendingIntent)"
    },
    "removeUpdates(android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdates(android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.Object,java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "request",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "requestLocationUpdates(java.lang.Object,java.lang.Object)"
    },
    "requestLocationUpdates(java.lang.Object,java.lang.Object,java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "request",
        "executorOrListener",
        "listenerOrLooper"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "requestLocationUpdates(java.lang.Object,java.lang.Object,java.lang.Object)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)"
    },
    "requestLocationUpdates(java.lang.String,long,float,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "requestLocationUpdates(java.lang.String,long,float,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(long,float,android.location.Criteria,android.location.LocationListener,android.os.Looper)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "requestLocationUpdates(long,float,android.location.Criteria,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.LocationRequest,android.app.PendingIntent)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "request",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.LocationRequest,android.app.PendingIntent)"
    },
    "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.LocationRequest,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "request",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.LocationRequest,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestSingleUpdate(android.location.Criteria,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(android.location.Criteria,android.app.PendingIntent)"
    },
    "requestSingleUpdate(android.location.Criteria,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(android.location.Criteria,android.location.LocationListener,android.os.Looper)"
    },
    "requestSingleUpdate(java.lang.String,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(java.lang.String,android.app.PendingIntent)"
    },
    "requestSingleUpdate(java.lang.String,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(java.lang.String,android.location.LocationListener,android.os.Looper)"
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()"
    },
    "sendGnssAntennaInfo(java.util.List\u003candroid.location.GnssAntennaInfo\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "antennaInfos"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendGnssAntennaInfo(java.util.List\u003candroid.location.GnssAntennaInfo\u003e)",
      "documentation": "Sends a GNSS measurement event to all registered {@link GnssMeasurementsEvent.Callback}s. "
    },
    "sendGnssMeasurementsEvent(android.location.GnssMeasurementsEvent)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "event"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendGnssMeasurementsEvent(android.location.GnssMeasurementsEvent)",
      "documentation": "Sends a GNSS measurement event to all registered {@link GnssMeasurementsEvent.Callback}s. "
    },
    "sendGnssStatus(android.location.GnssStatus)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "status"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendGnssStatus(android.location.GnssStatus)",
      "documentation": "Sends a {@link GnssStatus} to all registered {@link GnssStatus.Callback}s. "
    },
    "sendNmeaMessage(java.lang.String,long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "message",
        "timestamp"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendNmeaMessage(java.lang.String,long)",
      "documentation": "Sends a NMEA message to all registered {@link OnNmeaMessageListener}s. "
    },
    "setLastKnownLocation(java.lang.String,android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "location"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLastKnownLocation(java.lang.String,android.location.Location)",
      "documentation": "Sets the last known location for the given provider. "
    },
    "setLocationEnabled(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "enabled"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLocationEnabled(boolean)",
      "documentation": "On P and above, turns location on or off. On pre-P devices, sets the location mode to {@link\nandroid.provider.Settings.Secure#LOCATION_MODE_HIGH_ACCURACY} or {@link\nandroid.provider.Settings.Secure#LOCATION_MODE_OFF}.\n"
    },
    "setLocationEnabledForUser(boolean,android.os.UserHandle)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "enabled",
        "userHandle"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 28,
      "name": "setLocationEnabledForUser(boolean,android.os.UserHandle)"
    },
    "setLocationMode(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "locationMode"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLocationMode(int)",
      "documentation": "On pre-P devices, sets the device location mode. For P and above, use {@link\n#setLocationEnabled(boolean)} and {@link #setProviderEnabled(String, boolean)} in combination\nto achieve the desired effect.\n"
    },
    "setLocationModeInternal(int)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "locationMode"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLocationModeInternal(int)"
    },
    "setProviderEnabled(java.lang.String,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name",
        "enabled"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setProviderEnabled(java.lang.String,boolean)",
      "documentation": "Sets the given provider enabled or disabled. The provider will be created if it doesn\u0027t exist\nalready. On P and above, location must also be enabled via {@link #setLocationEnabled(boolean)}\nin order for a provider to be considered enabled.\n"
    },
    "setProviderProperties(java.lang.String,org.robolectric.shadows.ShadowLocationManager.ProviderProperties)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name",
        "properties"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setProviderProperties(java.lang.String,org.robolectric.shadows.ShadowLocationManager.ProviderProperties)",
      "documentation": "Sets the properties of the given provider. The provider will be created if it doesn\u0027t exist\nalready.\n"
    },
    "simulateLocation(android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "location"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateLocation(android.location.Location)",
      "documentation": "Delivers a new location to the appropriate listeners and updates state accordingly. Delivery\nwill ignore the enabled/disabled state of providers, unlike location on a real device.\n"
    },
    "unregisterAntennaInfoListener(android.location.GnssAntennaInfo.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "unregisterAntennaInfoListener(android.location.GnssAntennaInfo.Listener)"
    },
    "unregisterGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "unregisterGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback)"
    },
    "unregisterGnssStatusCallback(android.location.GnssStatus.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "unregisterGnssStatusCallback(android.location.GnssStatus.Callback)"
    }
  },
  "imports": [
    "android.location.LocationManager.GPS_PROVIDER",
    "android.location.LocationManager.NETWORK_PROVIDER",
    "android.location.LocationManager.PASSIVE_PROVIDER",
    "android.os.Build.VERSION_CODES.KITKAT",
    "android.os.Build.VERSION_CODES.LOLLIPOP",
    "android.os.Build.VERSION_CODES.N",
    "android.os.Build.VERSION_CODES.P",
    "android.os.Build.VERSION_CODES.Q",
    "android.os.Build.VERSION_CODES.R",
    "android.provider.Settings.Secure.LOCATION_MODE",
    "android.provider.Settings.Secure.LOCATION_MODE_BATTERY_SAVING",
    "android.provider.Settings.Secure.LOCATION_MODE_HIGH_ACCURACY",
    "android.provider.Settings.Secure.LOCATION_MODE_OFF",
    "android.provider.Settings.Secure.LOCATION_MODE_SENSORS_ONLY",
    "android.provider.Settings.Secure.LOCATION_PROVIDERS_ALLOWED",
    "java.util.concurrent.TimeUnit.NANOSECONDS",
    "android.app.PendingIntent",
    "android.app.PendingIntent.CanceledException",
    "android.content.Context",
    "android.content.Intent",
    "android.location.Criteria",
    "android.location.GnssAntennaInfo",
    "android.location.GnssMeasurementsEvent",
    "android.location.GnssStatus",
    "android.location.GpsStatus",
    "android.location.Location",
    "android.location.LocationListener",
    "android.location.LocationManager",
    "android.location.LocationProvider",
    "android.location.OnNmeaMessageListener",
    "android.os.Bundle",
    "android.os.CancellationSignal",
    "android.os.Handler",
    "android.os.Looper",
    "android.os.Process",
    "android.os.SystemClock",
    "android.os.UserHandle",
    "android.provider.Settings.Secure",
    "android.text.TextUtils",
    "androidx.annotation.GuardedBy",
    "androidx.annotation.Nullable",
    "java.lang.reflect.Constructor",
    "java.util.ArrayList",
    "java.util.Arrays",
    "java.util.Collections",
    "java.util.HashSet",
    "java.util.LinkedHashMap",
    "java.util.List",
    "java.util.Map",
    "java.util.Objects",
    "java.util.concurrent.CopyOnWriteArraySet",
    "java.util.concurrent.Executor",
    "java.util.concurrent.RejectedExecutionException",
    "java.util.function.Consumer",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadows.ShadowSettings.ShadowSecure",
    "org.robolectric.util.ReflectionHelpers",
    "org.robolectric.shadows.ShadowLocationManager.ProviderProperties",
    "org.robolectric.shadows.ShadowLocationManager.ProviderEntry",
    "org.robolectric.shadows.ShadowLocationManager.LocationRequest",
    "org.robolectric.shadows.ShadowLocationManager.LocationTransport",
    "org.robolectric.shadows.ShadowLocationManager.ListenerTransport",
    "org.robolectric.shadows.ShadowLocationManager.PendingIntentTransport",
    "org.robolectric.shadows.ShadowLocationManager.CancellableLocationListener",
    "org.robolectric.shadows.ShadowLocationManager.HandlerExecutor"
  ],
  "name": "org.robolectric.shadows.ShadowLocationManager",
  "documentation": "Shadow for {@link LocationManager}. Note that the default state of location on Android devices is\nlocation on, gps provider enabled, network provider disabled.\n"
}