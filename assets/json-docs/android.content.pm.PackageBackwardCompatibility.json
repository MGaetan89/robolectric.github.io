{
  "methods": {
    "addOptionalUpdater(java.util.List\u003ccom.android.server.pm.parsing.library.PackageSharedLibraryUpdater\u003e,java.lang.String,java.util.function.Supplier\u003ccom.android.server.pm.parsing.library.PackageSharedLibraryUpdater\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "packageUpdaters",
        "className",
        "defaultUpdater"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "addOptionalUpdater(java.util.List\u003ccom.android.server.pm.parsing.library.PackageSharedLibraryUpdater\u003e,java.lang.String,java.util.function.Supplier\u003ccom.android.server.pm.parsing.library.PackageSharedLibraryUpdater\u003e)",
      "documentation": "Stubbing this out as if Android S+ is on the classpath, we\u0027ll get a ClassCastException instead\nof a ClassNotFoundException. Since we don\u0027t really need this logic, simpler to just skip it\n"
    }
  },
  "imports": [
    "android.os.Build.VERSION_CODES.P",
    "com.android.server.pm.parsing.library.PackageSharedLibraryUpdater",
    "java.util.List",
    "java.util.function.Supplier",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements"
  ],
  "name": "org.robolectric.shadows.ShadowPackageBackwardCompatibility",
  "documentation": "Shadow of {@link PackageBackwardCompatibility} to handle a scenario that can come up when\nmultiple Android versions end up on the classpath\n"
}